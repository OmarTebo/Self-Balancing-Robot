// main_performance_test.cpp
// Hardware performance test for MPU6050 on ESP32 NodeMCU-32S
// - reads MPU6050 via MPU6050_Driver
// - converts to physical units via MPU6050_Processing
// - optionally runs MPU6050_Kalman
// - prints newline JSON per sample with timings + memory stats
//
// Put in <project>/src/ and flash. Open serial (115200) to view JSON output.
//
// Serial commands:
//  c -> calibrate gyro (samples = 512)
//  k -> toggle kalman on/off
//  s -> start/stop streaming
//  h -> help

#include <Arduino.h>
#include <Wire.h>

#include "MPU6050_Driver.h"
#include "MPU6050_Processing.h"
#include "MPU6050_Kalman.h"
#include "MPU6050_Config.h"

#ifdef ESP32
#include "esp_heap_caps.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#endif

// CONFIG
#ifndef LOG_BAUD
#define LOG_BAUD 115200
#endif

#ifndef TARGET_HZ
#define TARGET_HZ 200      // default sample rate (Hz)
#endif

#ifndef CALIB_SAMPLES
#define CALIB_SAMPLES 512
#endif

// Objects (use your existing driver implementation in lib/)
MPU6050_Driver drv(Wire, MPU6050_DEFAULT_ADDR);
MPU6050_Processing proc;
MPU6050_Kalman kalman;

bool streaming = true;
bool kalman_enabled = true;

unsigned long last_sample_us = 0;
const unsigned long sample_interval_us = 1000000UL / TARGET_HZ;

// Helper: perform gyro calibration using the driver directly
void do_calibrate_gyro(uint16_t samples = CALIB_SAMPLES) {
  Serial.println("{\"event\":\"calibrate_start\"}");
  uint64_t sumgx = 0, sumgy = 0, sumgz = 0;
  RawSample r;
  uint16_t got = 0;
  unsigned long start = millis();
  while (got < samples) {
    if (drv.readRaw(r)) {
      sumgx += (int32_t)r.gx;
      sumgy += (int32_t)r.gy;
      sumgz += (int32_t)r.gz;
      got++;
    }
    delay(2);
  }
  float offx = (float)sumgx / (float)samples;
  float offy = (float)sumgy / (float)samples;
  float offz = (float)sumgz / (float)samples;
  proc.setOffsets(0.0f, 0.0f, 0.0f, offx, offy, offz);
  unsigned long dur = millis() - start;
  Serial.printf("{\"event\":\"calibrate_done\",\"samples\":%u,\"dur_ms\":%lu}\n", samples, dur);
}

// Helper: print help
void print_help() {
  Serial.println("{\"help\":\"c=calibrate, k=toggle_kalman, s=start/stop, h=help\"}");
}

// Compose JSON line for one sample
void print_json_line(const RawSample &r, const ProcessedSample &ps,
                     const Angles &angles, unsigned long proc_us,
                     unsigned long filter_us, unsigned long loop_us) {
  // minimal compact JSON
  Serial.print("{");
  Serial.print("\"t_us\":"); Serial.print(r.t_us);
  Serial.print(",\"raw_ax\":"); Serial.print(r.ax);
  Serial.print(",\"raw_ay\":"); Serial.print(r.ay);
  Serial.print(",\"raw_az\":"); Serial.print(r.az);
  Serial.print(",\"raw_gx\":"); Serial.print(r.gx);
  Serial.print(",\"raw_gy\":"); Serial.print(r.gy);
  Serial.print(",\"raw_gz\":"); Serial.print(r.gz);

  Serial.print(",\"ax_g\":"); Serial.print(ps.ax_g,6);
  Serial.print(",\"ay_g\":"); Serial.print(ps.ay_g,6);
  Serial.print(",\"az_g\":"); Serial.print(ps.az_g,6);

  Serial.print(",\"gx_rads\":"); Serial.print(ps.gx_rads,6);
  Serial.print(",\"gy_rads\":"); Serial.print(ps.gy_rads,6);
  Serial.print(",\"gz_rads\":"); Serial.print(ps.gz_rads,6);

  Serial.print(",\"roll\":"); Serial.print(angles.roll,4);
  Serial.print(",\"pitch\":"); Serial.print(angles.pitch,4);
  Serial.print(",\"yaw\":"); Serial.print(angles.yaw,4);

  Serial.print(",\"proc_us\":"); Serial.print(proc_us);
  Serial.print(",\"filter_us\":"); Serial.print(filter_us);
  Serial.print(",\"loop_us\":"); Serial.print(loop_us);

  #ifdef ESP32
    Serial.print(",\"free_heap\":"); Serial.print(esp_get_free_heap_size());
    Serial.print(",\"stack_hw_mark\":"); Serial.print(uxTaskGetStackHighWaterMark(NULL));
  #endif

  // approximate CPU usage: (proc+filter)/interval *100
  unsigned long total_work_us = proc_us + filter_us;
  float cpu_pct = ((float)total_work_us * 100.0f) / (float)sample_interval_us;
  Serial.print(",\"cpu_pct_approx\":"); Serial.print(cpu_pct,2);

  Serial.println("}");
}

void setup() {
  Serial.begin(LOG_BAUD);
  delay(200);
  Serial.println("{\"event\":\"main_start\"}");
  print_help();

  // I2C init: call Wire.begin() with default pins (NodeMCU-32S typical SDA=21 SCL=22)
  Wire.begin();
  Wire.setClock(400000);

  // initialize driver & processing
  bool ok = drv.begin();
  Serial.printf("{\"event\":\"drv_begin\",\"ok\":%s}\n", ok ? "true" : "false");

  proc.setScales(16384.0f, 131.0f); // default scales
  // initialize Kalman
  kalman.begin(MPU_KALMAN_DEFAULT_UPDATE_HZ);
  kalman.reset();

  // Optionally auto-calibrate a few samples at startup (comment out if not desired)
  // do_calibrate_gyro(128);

  last_sample_us = micros();
}

void loop() {
  // handle commands
  if (Serial.available()) {
    char c = Serial.read();
    if (c == 'c') {
      do_calibrate_gyro(CALIB_SAMPLES);
    } else if (c == 'k') {
      kalman_enabled = !kalman_enabled;
      Serial.printf("{\"event\":\"kalman_toggle\",\"enabled\":%s}\n", kalman_enabled ? "true":"false");
      if (kalman_enabled) kalman.reset();
    } else if (c == 's') {
      streaming = !streaming;
      Serial.printf("{\"event\":\"streaming\",\"now\":%s}\n", streaming ? "true":"false");
    } else if (c == 'h') {
      print_help();
    }
  }

  if (!streaming) { delay(10); return; }

  unsigned long now_us = micros();
  unsigned long elapsed_us = now_us - last_sample_us;
  if (elapsed_us < sample_interval_us) {
    // small sleep to avoid busy loop
    delayMicroseconds(10);
    return;
  }
  unsigned long loop_start = micros();

  // 1) read raw sample from driver
  RawSample r;
  bool ok = drv.readRaw(r);
  if (!ok) {
    Serial.printf("{\"event\":\"read_failed\",\"t_us\":%lu}\n", micros());
    last_sample_us = micros();
    return;
  }

  // 2) process raw -> physical units
  unsigned long t0 = micros();
  ProcessedSample ps;
  proc.process(r, ps);
  unsigned long t1 = micros();
  unsigned long proc_us = t1 - t0;

  // 3) run filter (if enabled)
  unsigned long filter_us = 0;
  Angles angles;
  if (kalman_enabled) {
    unsigned long f0 = micros();
    // dt in seconds: use elapsed_us which is time since last sample (safer than micros deltas)
    float dt_s = (float)elapsed_us / 1000000.0f;
    if (dt_s <= 0.0f) dt_s = (float)sample_interval_us / 1000000.0f;
    kalman.update(ps, dt_s);
    kalman.getAngles(angles);
    unsigned long f1 = micros();
    filter_us = f1 - f0;
  } else {
    // accel-only fallback
    angles.roll = atan2f(ps.ay_g, ps.az_g) * 180.0f / M_PI;
    angles.pitch = atan2f(-ps.ax_g, sqrtf(ps.ay_g*ps.ay_g + ps.az_g*ps.az_g)) * 180.0f / M_PI;
    angles.yaw = 0.0f;
  }

  unsigned long loop_end = micros();
  unsigned long loop_us = loop_end - loop_start;

  print_json_line(r, ps, angles, proc_us, filter_us, loop_us);

  last_sample_us = now_us;
}
